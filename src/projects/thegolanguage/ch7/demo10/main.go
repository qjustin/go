package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
)

/*
	7.10. 类型断言
	类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，
	这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。

	第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类
	型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。
	如果检查失败，接下来这个操作会抛出panic。

	第二种，如果相反地断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，
	动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，对一个接
	口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态
	类型和值的部分。

	如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。
*/
const debug = true

func main() {
	var w io.Writer
	w = os.Stdout
	f := w.(*os.File)      // success: f == os.Stdout
	c := w.(*bytes.Buffer) // panic: interface holds *os.File, not *bytes.Buffer

	fmt.Println(f)
	fmt.Println(c)

	// 第二个结果通常赋值给一个命名为ok的变量。如果这个操作失败了，那么ok就是false值，
	if f, ok := w.(*os.File); ok {
		fmt.Println(f)
	}

	// 当类型断言的操作对象是一个变量，你有时会看见原来的变量名重用而不是声明一个新的本地变量名，这个重用的变量原来的值会被覆盖
	if w, ok := w.(*os.File); ok {
		fmt.Println(w)
	}
}
