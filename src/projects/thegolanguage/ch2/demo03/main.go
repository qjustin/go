package main

import (
	"fmt"
	"os"
)

/*

2.3.1. 简短变量声明

简短变量声明语句,用于声明和初始化局部变量,它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。
:= 要点：
0. 请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作
1. 只能用于函数内的局部变量，
2. 定义的同时必须赋值，变量的类型根据表达式来自动推导

var 要点：
1. 任意位置，函数内/外都可以，
2. 用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方
*/
// i := 100
// c, d := 3, 4
var boiling float64 = 100
var names []string
var err error
var a, b = 1, 2

func main() {
	i := 100
	// 简短变量声明语句也可以用来声明和初始化一组变量
	// 这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for语句的循环的初始化语句部分
	c, d := 3, 4

	// 请记住“:=”是一个变量声明语句，而“=”是一个变量赋值操作, 也不要混淆多个变量的声明和元组的多重赋值, 后者是将右边各个表达式的值赋值给左边对应位置的各个变量
	// 自己的总结 “:=” 有类型推断的功能，因此必须在声明的同时赋值，否则无法根据值来推断类型。而“=”无法类型推断，必须使用 var 声明
	var j = 200
	k := 300

	//交换 a 和 b 的值
	a, b = b, a
	fmt.Println(i)
	fmt.Println(boiling)
	fmt.Println(names)
	fmt.Println(err)
	fmt.Println(c)
	fmt.Println(d)
	fmt.Println(j)
	fmt.Println(k)
	// 简短变量声明语句也可以用函数的返回值来声明和初始化变量，像下面的os.Open函数调用将返回两个值：
	f, err := os.Open(names[0])
	if err != nil {
		fmt.Println(names[0])
	}
	f.Close()

	/*
		这里有一个比较微妙的地方：简短变量声明左边的变量可能并不是全部都是刚刚声明的。
		如果有一些已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。
		在下面的代码中，第一个语句声明了in和err1两个变量。在第二个语句只声明了out一个变量，然后对已经声明的err1进行了赋值操作。
	*/
	in, err1 := os.Open("c:\\txt")
	out, err1 := os.Create("c:\\txt")
	if err1 != nil {
		fmt.Println(names[0])
	}
	in.Close()
	out.Close()

	/*
		简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：

		f, err := os.Open(infile)
		f, err := os.Create(outfile) // compile error: no new variables

		解决的方法是第二个简短变量声明语句改用普通的多重赋值语句。

		简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，
		如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。我们在本章后面将会看到类似的例子。
	*/

}
