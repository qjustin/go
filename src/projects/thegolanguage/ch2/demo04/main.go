package main

import (
	"flag"
	"fmt"
	"strings"
)

var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")

/*
	2.3.2. 指针

	指针特别有价值的地方在于我们可以不用名字而访问一个变量

	变量: 一个变量对应一个保存了变量对应类型值的内存空间。
		  注意这里是“对应”

	指针：一个指针的值是另一个变量的地址,

	1、普通变量
	2、指针变量
	3、内存（内存空间）
	4、地址

	如 char a； 就是一个普通变量。普通变量a其实是语言本身创造了，
	是为了更方便的表示内存。我们对a进行访问其实就是直接对内存进行访问。
	至于a表示的内存的地址是多少，程序员一般不用关心。编译器会自动分配地址，
	也就是常说的为a分配一个地址。如果想知道a的地址也可以通过&a得知。

	再看指针变量，他和普通变量的区别在于，
	普通变量是和一块内存空间关联。而指针变量却是和两块内存空间想关联：

	1、保存指针变量本身的空间，这个空间大小是固定的，32位系统中是4个字节。
	2、指针指向的内存空间。


	如果说普通变量有两种形态：
	1、a   表示一块内存空间
	2、&a  表示当前内存空间的地址

   	那么指针变量就具有3种形态：
   1、a   表示指针a对应的内存空间（可以说就是指针本身的值）
   2、&a  表示当前指针对应的内存空间的首地址（存放指针的地址）
   3、*a  表示指针a所指向的变量对应的整个内存空间。（指针指向的空间）
*/
func main() {
	x := 1
	p := &x
	fmt.Println(*p)
	*p = 2
	fmt.Println(x)

	// 对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素
	// ——也都是对应一个变量，因此可以被取地址。

	// 对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素
	//——也都是对应一个变量，因此可以被取地址。
	var a, b int
	fmt.Println(&a == &a, &a == &b, &a == nil)
	// 在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，
	// 调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，
	// 因为指针p依然引用这个变量。
	var c = f()
	fmt.Println(c)

	// 因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。
	d := 1
	e := incr(&d)
	fmt.Println(e)
	fmt.Println(incr(&d))

	// 每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。
	// 例如，*p就是变量v的别名。指针特别有价值的地方在于我们可以不用名字而访问一个变量，
	g := 1
	fmt.Println(g)
	h := g
	fmt.Println(h)
	i := &g
	fmt.Println(*i)
	j := i
	fmt.Println(*j)

	// 值类型变量赋值操作，是拷贝副本，各自维护自己的值
	g++
	fmt.Println(g)
	fmt.Println(h)
	h++
	fmt.Println(g)
	fmt.Println(h)

	// 指针*i， *j 指向同一个地址，对*i，*j的修改会相互影响
	// 指针的价值：指针特别有价值的地方在于我们可以不用名字而访问一个变量
	*i++
	*j++
	fmt.Println(*i)
	fmt.Println(*j)

	/*
		命令行参数的例子

		调用flag.Bool函数会创建一个新的对应布尔型标志参数的变量。它有三个属性：
		第一个是命令行标志参数的名字“n”，然后是该标志参数的默认值（这里是false），
		最后是该标志参数对应的描述信息。如果用户在命令行输入了一个无效的标志参数，
		或者输入-h或-help参数，那么将打印所有标志参数的名字、默认值和描述信息。
		类似的，调用flag.String函数将创建一个对应字符串类型的标志参数变量，
		同样包含命令行标志参数对应的参数名、默认值、和描述信息。程序中的sep和n变量
		分别是指向对应命令行标志参数变量的指针，因此必须用*sep和*n形式的指针语法间接引用它们。

		当程序运行时，必须在使用标志参数对应的变量之前先调用flag.Parse函数，
		用于更新每个标志参数对应变量的值（之前是默认值）。对于非标志参数的普
		通命令行参数可以通过调用flag.Args()函数来访问，返回值对应一个字符串
		类型的slice。如果在flag.Parse函数解析命令行参数时遇到错误，默认将打
		印相关的提示信息，然后调用os.Exit(2)终止程序。
	*/

	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println()
	}
}

func f() *int {
	v := 1
	return &v
}

// 因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。
func incr(p *int) int {
	// 非常重要：只是增加p指向的变量的值，并不改变p指针！！！
	*p++
	// 返回*p指向变量的值
	return *p
}
